<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>素问抢答模拟</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
    <script src="avatar-generator.js"></script>
    <script src="avatar-selector.js"></script>
    <script src="game-state-manager.js"></script>
    <script src="animation-manager.js"></script>
    <script src="ui-controller.js"></script>
  
  <!-- 主游戏容器 -->
  <div class="quiz-container">
    <!-- 加分动画容器：用于显示分数增加时的飞行动画效果 -->
    <div class="score-animation-container" id="score-animation-container"></div>
    
    <!-- 顶部状态栏：显示玩家信息、计时器、对手信息 -->
    <div class="header">
      <!-- 玩家信息区域 -->
      <div class="player-info">
        <div class="avatar">You</div>
        <div class="player-score">0</div>
      </div>
      
      <!-- 计时器区域：显示当前题目剩余时间 -->
      <div class="timer-container">
        <div class="timer-circle">
          <!-- 计时器进度圆环 -->
          <div class="timer-progress"></div>
          <!-- 计时器数字显示 -->
          <span style="position: relative; z-index: 1;">0</span>
        </div>
      </div>
      
      <!-- 对手信息区域 -->
      <div class="opponent-info">
        <div class="opponent-score">
          <div class="score-number">0</div>
        </div>
        <div class="opponent-avatar"></div>
      </div>
    </div>

    <!-- 轮次提示文本：显示当前题目轮次或游戏状态 -->
    <div class="rank-text" id="rank-text"></div>
    
    <!-- 题目区域：包含题目内容、选项、进度条 -->
    <div class="question-section">
      <!-- 左侧进度条：显示玩家当前分数进度 -->
      <div class="progress-bar left-progress">
        <div class="progress-fill" id="left-progress-fill"></div>
      </div>
      
      <!-- 题目内容区域 -->
      <div class="question-content">
        <!-- 题目文本 -->
        <div class="question-text">
          当一个人认为"人人都在欺负我"时,最需要反思的是什么?
        </div>
        
        <!-- 选项容器：包含4个答题选项 -->
        <div class="options-container">
          <!-- 选项1：包含选项文本和对手结果图标 -->
          <div class="option" data-option="1">
            <div class="option-text">社会缺乏对弱者的保护机制</div>
            <div class="opponent-result" data-option="1"></div>
          </div>
          
          <!-- 选项2 -->
          <div class="option" data-option="2">
            <div class="option-text">是否侵犯了ta人的合法自由</div>
            <div class="opponent-result" data-option="2"></div>
          </div>
          
          <!-- 选项3 -->
          <div class="option" data-option="3">
            <div class="option-text">自身实力弱小,无法形成有效威慑</div>
            <div class="opponent-result" data-option="3"></div>
          </div>
          
          <!-- 选项4 -->
          <div class="option" data-option="4">
            <div class="option-text">ta人普遍存在的敌意</div>
            <div class="opponent-result" data-option="4"></div>
          </div>
        </div>
      </div>
      
      <!-- 右侧进度条：显示对手当前分数进度 -->
      <div class="progress-bar right-progress">
        <div class="progress-fill" id="right-progress-fill"></div>
      </div>
    </div>
    <!-- 结束界面：显示胜负颜文字与继续挑战按钮 -->
    <div class="end-screen" id="end-screen" style="display: none;">
      <div class="end-title" id="end-title">平局</div>
      <div class="end-emoji" id="end-emoji">(-__-°)</div>
      <button class="cta-button primary" id="continue-button">继续挑战</button>
    </div>
    
  </div>

    <!-- 底部题库来源声明 -->
    <div class="footer-attribution">
      <p>题库来源：<a href="https://sooon.ai/" target="_blank">素问</a>，详见
        <a href="about.html" >关于</a> ,可以通过
        <a href="#" id="settings-link">设置</a> 修改答题 AI 表现
      </p>
    </div>

    <!-- 设置模态框 -->
    <div class="modal-overlay" id="settings-modal">
      <div class="modal-content">
        <div class="modal-header">
          <h3>游戏设置</h3>
          <button class="modal-close" id="modal-close">&times;</button>
        </div>
        <div class="modal-body">
          <!-- 头像设置区域 -->
          <div class="setting-group">
            <label class="setting-label">头像设置</label>
            <div class="avatar-settings">
              <div class="avatar-setting-item">
                <div class="avatar-preview" id="user-avatar-preview">
                  <div class="avatar">You</div>
                </div>
                <div class="avatar-info">
                  <div class="avatar-name">用户头像</div>
                  <button class="btn btn-outline" id="change-user-avatar">修改用户头像</button>
                </div>
              </div>
              <div class="avatar-setting-item">
                <div class="avatar-preview" id="ai-avatar-preview">
                  <div class="opponent-avatar"></div>
                </div>
                <div class="avatar-info">
                  <div class="avatar-name">AI头像</div>
                  <button class="btn btn-outline" id="change-ai-avatar">修改AI头像</button>
                </div>
              </div>
            </div>
            <div class="setting-description">点击修改用户或AI的头像，支持自定义头像和随机生成。</div>
          </div>
          
          <!-- AI设置区域 -->
          <div class="setting-group">
            <label class="setting-label">AI正确率 (%)</label>
            <input type="number" id="ai-accuracy" class="setting-input" placeholder="请输入0-100的数字" min="0" max="100" step="1" pattern="[0-9]*" inputmode="numeric">
            <div class="setting-description">设置AI答题的正确率，0%表示总是答错，100%表示总是答对。仅允许输入数字。</div>
          </div>
          
          <div class="setting-group">
            <label class="setting-label">AI速度范围 (毫秒)</label>
            <div class="speed-inputs">
              <input type="number" id="ai-speed-min" class="setting-input" placeholder="最小数字" min="100" max="5000" step="100" pattern="[0-9]*" inputmode="numeric">
              <span class="speed-separator">-</span>
              <input type="number" id="ai-speed-max" class="setting-input" placeholder="最大数字" min="100" max="5000" step="100" pattern="[0-9]*" inputmode="numeric">
            </div>
            <div class="setting-description">设置AI作答的延迟时间范围，仅允许输入100-5000之间的数字。</div>
          </div>
          
          <!-- 头像固定设置 -->
          <div class="setting-group">
            <label class="setting-label">头像设置</label>
            <div class="checkbox-setting">
              <input type="checkbox" id="fix-opponent-avatar" class="setting-checkbox">
              <label for="fix-opponent-avatar" class="checkbox-label">固定对手头像</label>
            </div>
            <div class="setting-description">勾选后对手头像将固定不变，不勾选则每局游戏开始时刷新一次头像。</div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn btn-primary" id="save-settings">保存设置</button>
          <button class="btn btn-secondary" id="cancel-settings">取消</button>
        </div>
      </div>
    </div>

    <!-- 头像选择模态框 -->
    <div class="modal-overlay" id="avatar-modal">
      <div class="modal-content avatar-modal-content">
        <div class="modal-header">
          <h3>修改头像</h3>
          <button class="modal-close" id="avatar-modal-close">&times;</button>
        </div>
        <div class="modal-body">
          <!-- 当前头像显示 -->
          <div class="current-avatar-section">
            <div class="current-avatar-label">当前头像</div>
            <div class="current-avatar-display" id="current-avatar-display"></div>
          </div>
          
          <!-- 头像选择网格 -->
          <div class="avatar-grid-section">
            <div class="avatar-grid-label">选择头像</div>
            <div class="avatar-grid" id="avatar-grid">
              <!-- 4x4头像网格将通过JavaScript动态生成 -->
            </div>
          </div>
          
          <!-- 操作按钮 -->
          <div class="avatar-actions">
            <button class="btn btn-secondary" id="clear-avatar">清空选择</button>
            <button class="btn btn-primary" id="regenerate-avatars">重新生成</button>
          </div>
          
          <!-- 导入导出功能 -->
          <div class="avatar-import-export">
            <div class="import-export-label">头像管理</div>
            <div class="import-export-buttons">
              <button class="btn btn-outline" id="export-avatar">导出头像</button>
              <button class="btn btn-outline" id="import-avatar">导入头像</button>
              <input type="file" id="avatar-file-input" accept=".json" style="display: none;">
            </div>
          </div>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" id="cancel-avatar">取消</button>
          <button class="btn btn-primary" id="save-avatar">保存</button>
        </div>
      </div>
    </div>
  <script>
    /**
     * 答题对战游戏主脚本
     * 负责初始化游戏组件和协调各模块之间的交互
     */
    
    // 全局变量：存储游戏核心组件实例
    let gameStateManager;  // 状态管理器实例
    let uiController;      // UI控制器实例

    /**
     * 选项动画完成事件处理
     * 确保选项在CSS动画完成后正确显示
     */
    document.querySelectorAll('.option').forEach(option => {
      option.addEventListener('animationend', function() {
        this.classList.add('animate-in');
      });
    });

    /**
     * 页面加载完成事件处理
     * 初始化游戏组件并开始游戏流程
     */
    document.addEventListener('DOMContentLoaded', function() {
      console.log('页面加载完成，开始初始化游戏...');
      
      // 1. 创建状态管理器实例
      // 负责管理游戏的所有状态：分数、轮次、题目、计时器等
      gameStateManager = new GameStateManager();
      
      // 2. 创建UI控制器实例
      // 负责连接状态管理器和DOM操作，处理所有UI更新
      uiController = new UIController(gameStateManager);
      
      // 3. 设置初始游戏状态
      // 每次进入页面都视为一局新游戏，重置所有分数
      const initialPlayerScore = 0;    // 玩家初始分数
      const initialOpponentScore = 0;  // 对手初始分数
      const initialTimeLeft = 150;     // 初始倒计时（秒）
      
      // 更新状态管理器中的初始状态
      gameStateManager.updateState({
        playerScore: initialPlayerScore,
        opponentScore: initialOpponentScore,
        timeLeft: initialTimeLeft
      });

      // 3.1 配置对手参数（头像、AI准确率、选择速度）
      // 首先尝试加载保存的AI头像，如果没有则生成新的
      loadOpponentAvatar();

      // 3.1.1 添加AI头像点击事件
      const opponentAvatar = document.querySelector('.opponent-avatar');
      if (opponentAvatar && window.avatarSelector) {
        opponentAvatar.style.cursor = 'pointer';
        opponentAvatar.title = '点击修改AI头像';
        opponentAvatar.addEventListener('click', () => {
          window.avatarSelector.openModal('opponent');
        });
      }

      // 3.1.2 添加用户头像点击事件和加载保存的头像
      const playerAvatar = document.querySelector('.player-info .avatar');
      if (playerAvatar && window.avatarSelector) {
        playerAvatar.style.cursor = 'pointer';
        playerAvatar.title = '点击修改用户头像';
        playerAvatar.addEventListener('click', () => {
          window.avatarSelector.openModal('player');
        });
        
        // 加载保存的用户头像
        loadPlayerAvatar();
      }
      
      // 3.2 初始化设置模态框
      initializeSettingsModal();
      
      // 4. 立即更新UI显示
      // 确保页面加载时显示正确的初始状态
      setTimeout(() => {
        uiController.updatePlayerScore(initialPlayerScore);
        uiController.updateOpponentScore(initialOpponentScore);
        
        uiController.updateTimer(initialTimeLeft);
        // 同步一次头像显示
        uiController.updateOpponentAvatar(gameStateManager.getState('opponent')?.avatar);
        console.log('UI初始化完成，倒计时设置为', initialTimeLeft, '秒');
      }, 100);
        
      // 5. 开始新一局游戏
      // 延迟500ms开始游戏，确保所有组件都已正确初始化
      setTimeout(() => {
        gameStateManager.startNewGame();
        console.log('游戏开始！');
      }, 500);
        
      console.log('游戏初始化完成');

      // 暴露调试函数到全局：window.debugSettle(0|1|2)
      window.debugSettle = function(mode){
        if (!gameStateManager) return;
        if (typeof gameStateManager.debugSettle === 'function') {
          gameStateManager.debugSettle(Number(mode));
        }
      };
      // 控制台输出大提示说明可设置的mode
      console.log('可设置的mode: 0-平局, 1-玩家胜, 2-对手胜');
      console.log('方法：debugSettle(0|1|2)');
    });
    
    /**
     * 初始化设置模态框
     * 从localStorage加载保存的状态，并设置事件监听器
     */
    function initializeSettingsModal() {
      const settingsLink = document.getElementById('settings-link');
      const settingsModal = document.getElementById('settings-modal');
      const modalClose = document.getElementById('modal-close');
      const cancelSettings = document.getElementById('cancel-settings');
      const saveSettings = document.getElementById('save-settings');
      const speedMinElement = document.getElementById('ai-speed-min');
      const speedMaxElement = document.getElementById('ai-speed-max');
      const accuracyElement = document.getElementById('ai-accuracy');
      const fixAvatarElement = document.getElementById('fix-opponent-avatar');
      
      if (!settingsLink || !settingsModal || !speedMinElement || !speedMaxElement || !accuracyElement || !fixAvatarElement) {
        console.warn('设置模态框元素未找到');
        return;
      }
      
      // 从localStorage加载保存的状态
      const savedSpeedMin = localStorage.getItem('aiSpeedMin');
      const savedSpeedMax = localStorage.getItem('aiSpeedMax');
      const savedAccuracy = localStorage.getItem('aiAccuracy');
      const savedAvatarFixed = localStorage.getItem('avatarFixed');
      
      const speedMin = savedSpeedMin ? parseInt(savedSpeedMin) : 1280;
      const speedMax = savedSpeedMax ? parseInt(savedSpeedMax) : 2900;
      const accuracy = savedAccuracy ? parseFloat(savedAccuracy) : 0;
      const avatarFixed = savedAvatarFixed ? JSON.parse(savedAvatarFixed) : false;
      
      // 设置初始值
      speedMinElement.value = speedMin;
      speedMaxElement.value = speedMax;
      accuracyElement.value = accuracy;
      fixAvatarElement.checked = avatarFixed;
      
      // 更新头像预览
      updateAvatarPreviews();
      
      // 更新游戏状态管理器中的状态
      if (gameStateManager) {
        gameStateManager.updateState({ 
          aiSpeedRange: [speedMin, speedMax],
          aiAccuracy: accuracy / 100 // 转换为0-1范围
        });
        // 设置头像固定状态
        gameStateManager.setAvatarFixed(avatarFixed);
      }
      
      // 打开模态框
      function openModal() {
        settingsModal.classList.add('show');
        document.body.style.overflow = 'hidden';
      }
      
      // 关闭模态框
      function closeModal() {
        settingsModal.classList.remove('show');
        document.body.style.overflow = '';
      }
      
      // 数据验证和修正函数
      function validateAndCorrectInputs() {
        let hasError = false;
        
        // 验证正确率
        let accuracy = parseFloat(accuracyElement.value);
        if (isNaN(accuracy)) {
          // 如果输入为空或无效，保持原值不自动修正
          accuracyElement.classList.remove('input-error');
        } else if (accuracy < 0 || accuracy > 100) {
          // 超出范围时自动修正并显示错误状态
          accuracy = Math.max(0, Math.min(100, accuracy));
          accuracyElement.value = accuracy;
          accuracyElement.classList.add('input-error');
          hasError = true;
        } else {
          accuracyElement.classList.remove('input-error');
        }
        
        // 验证速度范围
        let min = parseInt(speedMinElement.value);
        let max = parseInt(speedMaxElement.value);
        
        if (isNaN(min)) {
          speedMinElement.classList.remove('input-error');
        } else if (min < 100 || min > 5000) {
          min = Math.max(100, Math.min(5000, min));
          speedMinElement.value = min;
          speedMinElement.classList.add('input-error');
          hasError = true;
        } else {
          speedMinElement.classList.remove('input-error');
        }
        
        if (isNaN(max)) {
          speedMaxElement.classList.remove('input-error');
        } else if (max < 100 || max > 5000) {
          max = Math.max(100, Math.min(5000, max));
          speedMaxElement.value = max;
          speedMaxElement.classList.add('input-error');
          hasError = true;
        } else {
          speedMaxElement.classList.remove('input-error');
        }
        
        // 确保最小值不大于最大值（仅在两个值都有效时检查）
        if (!isNaN(min) && !isNaN(max) && min > max) {
          const temp = min;
          min = max;
          max = temp;
          speedMinElement.value = min;
          speedMaxElement.value = max;
          speedMinElement.classList.add('input-error');
          speedMaxElement.classList.add('input-error');
          hasError = true;
        }
        
        return { accuracy, min, max, hasError };
      }
      
      // 数字输入过滤函数
      function filterNumericInput(element) {
        // 移除所有非数字字符（包括负号、小数点等）
        const originalValue = element.value;
        const numericValue = originalValue.replace(/[^0-9]/g, '');
        
        if (originalValue !== numericValue) {
          element.value = numericValue;
          element.classList.add('input-error');
          
          // 显示过滤提示
          showCorrectionTip(element, '仅允许输入数字');
          
          // 短暂显示错误状态后清除
          setTimeout(() => {
            element.classList.remove('input-error');
          }, 1000);
        }
      }
      
      // 键盘事件过滤函数
      function handleKeyPress(e) {
        const allowedKeys = [
          'Backspace', 'Delete', 'Tab', 'Enter', 'Escape',
          'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown',
          'Home', 'End'
        ];
        
        // 允许的功能键
        if (allowedKeys.includes(e.key)) {
          return;
        }
        
        // 只允许数字键
        if (!/^[0-9]$/.test(e.key)) {
          e.preventDefault();
          showCorrectionTip(e.target, '仅允许输入数字');
        }
      }
      
      // 智能输入处理函数
      function handleSmartInput(element, min, max, defaultValue) {
        // 首先过滤非数字字符
        filterNumericInput(element);
        
        const value = parseInt(element.value);
        
        // 如果输入为空，不处理
        if (element.value === '') {
          element.classList.remove('input-error');
          return;
        }
        
        // 如果输入无效数字
        if (isNaN(value)) {
          element.classList.add('input-error');
          return;
        }
        
        // 如果超出范围，自动修正
        if (value < min || value > max) {
          const correctedValue = Math.max(min, Math.min(max, value));
          element.value = correctedValue;
          element.classList.add('input-error');
          
          // 显示修正提示
          showCorrectionTip(element, `已自动修正为 ${correctedValue}`);
        } else {
          element.classList.remove('input-error');
        }
      }
      
      // 显示修正提示
      function showCorrectionTip(element, message) {
        // 创建提示元素
        let tip = element.parentNode.querySelector('.correction-tip');
        if (!tip) {
          tip = document.createElement('div');
          tip.className = 'correction-tip';
          tip.style.cssText = `
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #ff9800;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1000;
            margin-top: 2px;
          `;
          element.parentNode.style.position = 'relative';
          element.parentNode.appendChild(tip);
        }
        
        tip.textContent = message;
        tip.style.display = 'block';
        
        // 3秒后自动隐藏
        setTimeout(() => {
          tip.style.display = 'none';
        }, 3000);
      }
      
      // 实时输入监听
      function addInputListeners() {
        // 为所有输入框添加键盘事件监听
        [accuracyElement, speedMinElement, speedMaxElement].forEach(element => {
          // 键盘按下事件监听
          element.addEventListener('keydown', handleKeyPress);
          
          // 粘贴事件监听
          element.addEventListener('paste', function(e) {
            // 延迟处理粘贴内容
            setTimeout(() => {
              filterNumericInput(this);
            }, 10);
          });
        });
        
        // 正确率输入框监听
        accuracyElement.addEventListener('input', function() {
          handleSmartInput(this, 0, 100, 0);
        });
        
        // 速度范围输入框监听
        speedMinElement.addEventListener('input', function() {
          handleSmartInput(this, 100, 5000, 100);
        });
        
        speedMaxElement.addEventListener('input', function() {
          handleSmartInput(this, 100, 5000, 5000);
        });
        
        // 失去焦点时的最终验证和保存
        accuracyElement.addEventListener('blur', function() {
          const result = validateAndCorrectInputs();
          if (!result.hasError && !isNaN(result.accuracy)) {
            // 保存到localStorage
            localStorage.setItem('aiAccuracy', result.accuracy.toString());
            // 更新游戏状态
            if (gameStateManager) {
              gameStateManager.updateState({ 
                aiAccuracy: result.accuracy / 100
              });
            }
          }
        });
        
        speedMinElement.addEventListener('blur', function() {
          const result = validateAndCorrectInputs();
          if (!result.hasError && !isNaN(result.min)) {
            localStorage.setItem('aiSpeedMin', result.min.toString());
            // 更新游戏状态
            if (gameStateManager) {
              gameStateManager.updateState({ 
                aiSpeedRange: [result.min, result.max]
              });
            }
          }
        });
        
        speedMaxElement.addEventListener('blur', function() {
          const result = validateAndCorrectInputs();
          if (!result.hasError && !isNaN(result.max)) {
            localStorage.setItem('aiSpeedMax', result.max.toString());
            // 更新游戏状态
            if (gameStateManager) {
              gameStateManager.updateState({ 
                aiSpeedRange: [result.min, result.max]
              });
            }
          }
        });
        
        // 键盘事件监听（Enter键保存）
        [accuracyElement, speedMinElement, speedMaxElement].forEach(element => {
          element.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
              const result = validateAndCorrectInputs();
              if (!result.hasError) {
                // 自动保存并更新状态
                if (this === accuracyElement && !isNaN(result.accuracy)) {
                  localStorage.setItem('aiAccuracy', result.accuracy.toString());
                  if (gameStateManager) {
                    gameStateManager.updateState({ aiAccuracy: result.accuracy / 100 });
                  }
                } else if ((this === speedMinElement || this === speedMaxElement) && 
                          !isNaN(result.min) && !isNaN(result.max)) {
                  localStorage.setItem('aiSpeedMin', result.min.toString());
                  localStorage.setItem('aiSpeedMax', result.max.toString());
                  if (gameStateManager) {
                    gameStateManager.updateState({ aiSpeedRange: [result.min, result.max] });
                  }
                }
              }
            }
          });
        });
      }
      
      // 保存设置
      function saveSettingsHandler() {
        const result = validateAndCorrectInputs();
        
        if (result.hasError) {
          // 显示错误提示
          alert('请检查输入值是否在有效范围内：\n- 正确率：0-100%\n- 速度范围：100-5000ms');
          return;
        }
        
        // 获取头像固定设置
        const avatarFixed = fixAvatarElement.checked;
        
        // 如果用户勾选了固定头像，保存当前显示的头像
        if (avatarFixed) {
          const currentOpponentAvatar = document.querySelector('.opponent-avatar');
          if (currentOpponentAvatar && currentOpponentAvatar.innerHTML) {
            // 获取当前头像的HTML内容
            const currentAvatarHTML = currentOpponentAvatar.innerHTML;
            
            // 构造头像数据对象
            const avatarData = {
              svg: currentAvatarHTML,
              style: 'current',
              seed: 'fixed-' + Date.now(),
              timestamp: Date.now(),
              isFixed: true
            };
            
            // 保存当前头像到localStorage
            localStorage.setItem('sooon-avatar-data', JSON.stringify(avatarData));
            console.log('已保存当前头像用于固定显示');
          }
        }
        
        // 更新游戏状态管理器
        if (gameStateManager) {
          gameStateManager.updateState({ 
            aiSpeedRange: [result.min, result.max],
            aiAccuracy: result.accuracy / 100 // 转换为0-1范围
          });
          // 设置头像固定状态
          gameStateManager.setAvatarFixed(avatarFixed);
        }
        
        // 保存到localStorage
        localStorage.setItem('aiSpeedMin', result.min.toString());
        localStorage.setItem('aiSpeedMax', result.max.toString());
        localStorage.setItem('aiAccuracy', result.accuracy.toString());
        localStorage.setItem('avatarFixed', JSON.stringify(avatarFixed));
        
        console.log('AI设置已保存 - 速度范围:', result.min + '-' + result.max + 'ms', '正确率:', result.accuracy + '%', '头像固定:', avatarFixed ? '是' : '否');
        
        closeModal();
      }
      
      // 初始化输入监听
      addInputListeners();
      
      // 头像修改按钮事件监听器
      const changeUserAvatarBtn = document.getElementById('change-user-avatar');
      const changeAiAvatarBtn = document.getElementById('change-ai-avatar');
      
      if (changeUserAvatarBtn && window.avatarSelector) {
        changeUserAvatarBtn.addEventListener('click', function() {
          window.avatarSelector.openModal('player');
        });
      }
      
      if (changeAiAvatarBtn && window.avatarSelector) {
        changeAiAvatarBtn.addEventListener('click', function() {
          window.avatarSelector.openModal('opponent');
        });
      }
      
      // 事件监听器
      settingsLink.addEventListener('click', function(e) {
        e.preventDefault();
        openModal();
      });
      
      modalClose.addEventListener('click', closeModal);
      cancelSettings.addEventListener('click', closeModal);
      saveSettings.addEventListener('click', saveSettingsHandler);
      
      // 点击模态框背景关闭
      settingsModal.addEventListener('click', function(e) {
        if (e.target === settingsModal) {
          closeModal();
        }
      });
      
      // ESC键关闭模态框
      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && settingsModal.classList.contains('show')) {
          closeModal();
        }
      });
      
      console.log('设置模态框初始化完成');
      console.log('当前设置 - 速度范围:', speedMin + '-' + speedMax + 'ms', '正确率:', accuracy + '%');
    }
    
    /**
     * 加载保存的AI头像
     */
    function loadOpponentAvatar() {
      try {
        // 首先检查头像固定设置
        const savedAvatarFixed = localStorage.getItem('avatarFixed');
        const avatarFixed = savedAvatarFixed ? JSON.parse(savedAvatarFixed) : false;
        
        const savedAvatarData = localStorage.getItem('sooon-avatar-data');
        if (savedAvatarData) {
          const avatarData = JSON.parse(savedAvatarData);
          const opponentAvatar = document.querySelector('.opponent-avatar');
          
          if (opponentAvatar && avatarData.svg) {
            // 清空默认内容并设置保存的头像
            opponentAvatar.innerHTML = '';
            opponentAvatar.insertAdjacentHTML('beforeend', avatarData.svg);
            console.log('AI头像已从本地存储加载:', avatarData.style, avatarData.seed);
            
            // 更新游戏状态管理器中的头像和固定状态
            if (gameStateManager) {
              gameStateManager.configureOpponent({
                avatar: avatarData.svg,
                avatarFixed: avatarFixed,
                ai: { accuracy: 0, speedMsRange: [1280, 2900] }
              });
            }
            return; // 成功加载保存的头像，直接返回
          }
        }
        
        // 如果没有保存的头像，检查是否固定头像
        if (avatarFixed) {
          console.log('头像设置为固定，但没有保存的头像，使用默认头像');
          const opponentAvatar = document.querySelector('.opponent-avatar');
          if (opponentAvatar) {
            opponentAvatar.innerHTML = '🤖'; // 使用默认头像
          }
          // 更新游戏状态管理器
          if (gameStateManager) {
            gameStateManager.configureOpponent({
              avatar: '🤖',
              avatarFixed: avatarFixed,
              ai: { accuracy: 0, speedMsRange: [1280, 2900] }
            });
          }
          return;
        }
        
        // 如果没有保存的头像且不固定，生成新的AI头像
        console.log('未找到保存的AI头像且未固定，生成新头像');
        generateNewOpponentAvatar();
      } catch (error) {
        console.error('加载AI头像失败:', error);
        // 出错时也生成新头像
        generateNewOpponentAvatar();
      }
    }

    /**
     * 生成新的AI头像
     */
    function generateNewOpponentAvatar() {
      let aiAvatar = '🤖'; // 默认头像
      if (window.avatarGenerator) {
        try {
          // 异步设置头像到DOM元素
          window.avatarGenerator.setAvatarToElement('.opponent-avatar').then(avatarData => {
            if (avatarData) {
              aiAvatar = avatarData.svg; // 使用生成的SVG头像
              console.log('AI头像已生成，风格:', avatarData.style, '种子:', avatarData.seed);
              
              // 更新游戏状态管理器中的头像
              if (gameStateManager) {
                // 检查头像固定设置
                const savedAvatarFixed = localStorage.getItem('avatarFixed');
                const avatarFixed = savedAvatarFixed ? JSON.parse(savedAvatarFixed) : false;
                
                gameStateManager.configureOpponent({
                  avatar: aiAvatar,
                  avatarFixed: avatarFixed,
                  ai: { accuracy: 0, speedMsRange: [1280, 2900] }
                });
              }
            }
          }).catch(error => {
            console.warn('头像生成失败，使用默认头像:', error);
            if (gameStateManager) {
              // 检查头像固定设置
              const savedAvatarFixed = localStorage.getItem('avatarFixed');
              const avatarFixed = savedAvatarFixed ? JSON.parse(savedAvatarFixed) : false;
              
              gameStateManager.configureOpponent({
                avatar: aiAvatar,
                avatarFixed: avatarFixed,
                ai: { accuracy: 0, speedMsRange: [1280, 2900] }
              });
            }
          });
        } catch (error) {
          console.warn('头像生成失败，使用默认头像:', error);
        }
      }
      
      // 如果头像生成器不可用，立即配置对手
      if (!window.avatarGenerator && gameStateManager) {
        // 检查头像固定设置
        const savedAvatarFixed = localStorage.getItem('avatarFixed');
        const avatarFixed = savedAvatarFixed ? JSON.parse(savedAvatarFixed) : false;
        
        gameStateManager.configureOpponent({
          avatar: aiAvatar,
          avatarFixed: avatarFixed,
          ai: { accuracy: 0, speedMsRange: [1280, 2900] }
        });
      }
    }
    
    // 将函数暴露到全局作用域，供游戏状态管理器调用
    window.generateNewOpponentAvatar = generateNewOpponentAvatar;

    /**
     * 加载保存的用户头像
     */
    function loadPlayerAvatar() {
      try {
        const savedAvatarData = localStorage.getItem('sooon-player-avatar-data');
        if (savedAvatarData) {
          const avatarData = JSON.parse(savedAvatarData);
          const playerAvatar = document.querySelector('.player-info .avatar');
          
          if (playerAvatar && avatarData.svg) {
            // 清空默认内容并设置保存的头像
            playerAvatar.innerHTML = '';
            playerAvatar.insertAdjacentHTML('beforeend', avatarData.svg);
            console.log('用户头像已从本地存储加载:', avatarData.style, avatarData.seed);
          }
        } else {
          console.log('未找到保存的用户头像，使用默认头像');
        }
      } catch (error) {
        console.error('加载用户头像失败:', error);
      }
    }

    /**
     * 更新头像预览
     */
    function updateAvatarPreviews() {
      // 更新用户头像预览
      const userAvatarPreview = document.getElementById('user-avatar-preview');
      const userAvatar = document.querySelector('.player-info .avatar');
      if (userAvatarPreview && userAvatar) {
        userAvatarPreview.innerHTML = userAvatar.innerHTML;
      }
      
      // 更新AI头像预览
      const aiAvatarPreview = document.getElementById('ai-avatar-preview');
      const aiAvatar = document.querySelector('.opponent-avatar');
      if (aiAvatarPreview && aiAvatar) {
        aiAvatarPreview.innerHTML = aiAvatar.innerHTML;
      }
    }
    
    // 将函数暴露到全局作用域，供头像选择器调用
    window.updateAvatarPreviews = updateAvatarPreviews;
    
    /**
     * 页面卸载事件处理
     * 清理资源，防止内存泄漏
     */
    window.addEventListener('beforeunload', function() {
      console.log('页面即将卸载，开始清理资源...');
      
      // 清理状态管理器
      if (gameStateManager) {
        gameStateManager.destroy();
        console.log('状态管理器已清理');
      }
      
      // 清理UI控制器
      if (uiController) {
        uiController.destroy();
        console.log('UI控制器已清理');
      }
      
      console.log('资源清理完成');
    });
  </script>
</body>
</html>